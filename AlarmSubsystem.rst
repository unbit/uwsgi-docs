The uWSGI alarm subsystem (from 1.3) 
====================================

Starting from 1.3, uWSGI includes an alarm system to allow the developer/sysadmin to 'announce' special conditions of your app via various channels.

For example you may want to get notified via Jabber/XMPP of a full listen queue, or a harakiri condition.

The alarm subsystem is based on realtime log-parsing: when a specific log line matches a regexp, a specific alarm will be triggered.


Defining an alarm
*****************

You can define an unlimited number of alarms. Each alarm has a unique name, and its channel is exported by a plugin.

Currently the following plugins are available in the main distribution:

.. parsed-literal::
   'cmd' run a command passing the log line to the stdin
   'signal' generate a uwsgi signal
   'mule' send the log line to a mule
   'curl' pass the log line to a curl url (http,https and smtp are supported)
   'xmpp' send the log line via XMPP/jabber


To define an alarm you use the option **--alarm**

.. parsed-literal::
   --alarm "<name> <plugin>:<opts>"


(remember to quote ONLY when you are defining alarms on the command line)

.. code-block:: ini
   
   [uwsgi]
   alarm = mailme cmd:mail -s 'uWSGI alarm' -a 'From: foobar@example.com' admin@example.com
   alarm = cachefull signal:17


here we define to alarm: mailme and cachefull. The first one invokes the 'mail' command to send the logline to a mail address
the second one generate a uwsgi signal.

We now need to add rules to trigger alarms:

.. code-block:: ini
   
   [uwsgi]
   alarm = mailme cmd:mail -s 'uWSGI alarm' -a 'From: foobar@example.com' admin@example.com
   alarm = cachefull signal:17
   log-alarm = cachefull,mailme uWSGI listen queue of socket
   log-alarm = mailme HARAKIRI ON WORKER



the syntax of log-alarm is

.. parsed-literal::
   --log-alarm "<name> <regexp>"


So in our previous example we defined two conditions (via regexp applied to logs), the first one will trigger both the alarms when the listen queue is full, while the second
will invoke only the 'mailme' one when a harakiri on a worker is running.



Damn, it is the rawest thing i ever seen....
********************************************

Yes for sure, but if you throw away for a moment your "being a cool programmer with a lot of friends and zero money" book, you will realize
how many things you can do with such a simple system.

Want an example ?

.. code-block:: ini
   
   [uwsgi]
   alarm = jabber xmpp:foobar@jabber.xxx;mysecretpassword;admin@jabber.xxx,admin2@jabber.xxx
   log-alarm = jabber ^TERRIBLE ALARM


now in your app you only need to

.. code-block:: python

   print "TERRIBLE ALARM the world exploded !!!"


to send a jabber message to admin@jabber.xxx and admin2@jabber.xxx without adding overhead to your app (as alarms are triggered by one or more threads in the master, without bothering workers).

Another example ?

Check this Rack middleware

.. code-block:: rb

   class UploadCheck
     def initialize(app)
       @app = app       
     end                
   
     def call(env)
       if env['REQUEST_METHOD'] == 'POST' and env['PATH_INFO'] == '/upload'
         puts "TERRIBLE ALARM an upload has been made"
       end   
       @app.call(env)   
     end                
   end               


Protecting from bad rules
*************************

Such a versatile system could open to a lot of ugly bugs (mainly loops), so try to build your regexp
carefully. An embedded anti-loop subsystem should protect you from loglines wrongly generated by alarm plugin,
but it cannot be perfect, so check twice your regexps.

If you are building a plugin be sure to prepend your log messages with the '[uwsgi-alarm' string. Lines starting with such
string will be skipped and directly passed to the log subsystem. A commodity api function is available: '''uwsgi_log_alarm()'''


How dows it work ?
******************

Enabling an alarm, automatically put the uWSGI instance in log-master mode. Such a mode delegates log writes to the master.
The alarm subsystem is executed by the master just before passing the log line to the log plugin. Blocking alarm plugins should
run in a thread (like the curl and xmpp one), while the simple ones (like signal and cmd) run directly in the master.


Available plugins and their syntax
**********************************

cmd
^^^

run a shell command (logline is passed to the stdin)

.. parsed-literal::
   cmd:<command>
 

signal
^^^^^^

raise a [wiki:SignalFramework] uwsgi signal

.. parsed-literal::
   signal:[signum]

mule
^^^^

send the logline to a mule waiting for [wiki:Mules messages]

.. parsed-literal::
   mule:[mule_id]


curl
^^^^

Send logline to a curl url. This is not compiled in by default, so if you need to build it just run

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_curl


.. parsed-literal::
   curl:<url>[;opt1=val1;opt2=val2]


url is a standard curl url, while the options currently exposed are

.. code-block:: c

   "url"
   "mail_to"
   "mail_from"
   "subject"
   "ssl"
   "auth_user"
   "auth_pass"
   "method"
   "timeout"
   "conn_timeout"


so, for sending mail via SMTP AUTH:

.. code-block:: ini

   [uwsgi]
   plugins = alarm_curl
   alarm = test curl:smtp://mail.example.com;mail_to=admin@example.com;mail_from=uwsgi@example.com;auth_user=uwsgi;auth_pass=secret;subject=alarm from uWSGI !!!


or to POST the logline to an http server protected with basic auth

.. code-block:: ini

   [uwsgi]
   plugins = alarm_curl
   alarm = test2 curl:http://192.168.173.6:9191/argh;auth_user=topogigio;auth_pass=foobar


xmpp
^^^^

Probably the most funny one. You neeg libgloox to build it (apt-get install gloox-dev)

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_xmpp


.. parsed-literal::
   xmpp:<jid>;<password>;<recipients>


you can set multiple recipients using ',' as delimiter


.. code-block:: ini

   [uwsgi]
   plugins = alarm_xmpp
   alarm = jabber xmpp:app@example.it;secret1;foo1@foo.it,foo2@foo.it


A very funny thing about the xmpp plugin is that you will se the jabber account of your app going down when your app dies...

Some XMPP server (most notably the OSX server one) requires you to bind to a resource. You can do it appending /resource to the JID:

.. code-block:: ini

   [uwsgi]
   plugins = alarm_xmpp
   alarm = jabber xmpp:app@example.it/uWSGI;secret1;foo1@foo.it,foo2@foo.it

speech
^^^^^^

A joke plugin for OSX, used mainly for showing objective-c integration with uWSGI.
It simply uses the speechsynthesizer to 'announce' the alarm

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_speech

.. code-block:: ini

   [uwsgi]
   plugins = alarm_speech
   http-socket = :8080
   alarm = say speech:
   log-alarm = say .*

turn on your amplifiers, run uWSGI and start listening...

******
Notes
******

Nothing particular, enjoy it :)
