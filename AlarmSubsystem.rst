The uWSGI alarm subsystem (from 1.3) 
====================================

As of 1.3, uWSGI includes an alarm system. This subsystem allows the
developer/sysadmin to 'announce' special conditions of an app via various
channels.  For example, you may want to get notified via Jabber/XMPP of a full
listen queue, or a harakiri condition.  The alarm subsystem is based on
realtime log-parsing: when a specific log line matches a regexp, a specific
alarm will be triggered.


Defining an alarm
*****************

You can define an unlimited number of alarms. Each alarm has a unique name, and
its channel is exported by a plugin.  Currently the following plugins are
available in the main distribution:

.. parsed-literal::
   'cmd' run a command passing the log line to the stdin
   'signal' generate a uwsgi signal
   'mule' send the log line to a mule
   'curl' pass the log line to a curl url (http,https and smtp are supported)
   'xmpp' send the log line via XMPP/jabber


To define an alarm, use the option ``--alarm``.

.. parsed-literal::
   --alarm "<name> <plugin>:<opts>"

Remember to quote ONLY when you are defining alarms on the command line.

.. code-block:: ini
   
   [uwsgi]
   alarm = mailme cmd:mail -s 'uWSGI alarm' -a 'From: foobar@example.com' admin@example.com
   alarm = cachefull signal:17

Here we define two alarms: ``mailme`` and ``cachefull``. The first one invokes
the ``mail`` binary to send the log line to a mail address; the second one
generates an uWSGI signal.  We now need to add rules to trigger alarms:

.. code-block:: ini
   
   [uwsgi]
   alarm = mailme cmd:mail -s 'uWSGI alarm' -a 'From: foobar@example.com' admin@example.com
   alarm = cachefull signal:17
   log-alarm = cachefull,mailme uWSGI listen queue of socket
   log-alarm = mailme HARAKIRI ON WORKER

The syntax of log-alarm is

.. parsed-literal::
   --log-alarm "<name> <regexp>"


In our previous example we defined two conditions using regexps applied to log
lines. The first one will trigger both alarms when the listen queue is full,
while the second will only invoke 'mailme' when a worker commits harakiri.

Damnit, this... this is the rawest thing I've seen...
*****************************************************

You may be right. But if you throw away your "being a cool programmer with a
lot of friends and zero money" book for a moment, you will realize just how
many things you can do with such a simple system.  Want an example?

.. code-block:: ini
   
   [uwsgi]
   alarm = jabber xmpp:foobar@jabber.xxx;mysecretpassword;admin@jabber.xxx,admin2@jabber.xxx
   log-alarm = jabber ^TERRIBLE ALARM

Now in your app you only need to add

.. code-block:: python

   print "TERRIBLE ALARM the world exploded !!!"

to send a jabber message to ``admin@jabber.xxx`` and ``admin2@jabber.xxx``
without adding any significant overhead to your app (as alarms are triggered by
one or more threads in the master process, without bothering workers).

How about another example?

Check this Rack middleware:

.. code-block:: rb

   class UploadCheck
     def initialize(app)
       @app = app       
     end                
   
     def call(env)
       if env['REQUEST_METHOD'] == 'POST' and env['PATH_INFO'] == '/upload'
         puts "TERRIBLE ALARM an upload has been made"
       end   
       @app.call(env)   
     end                
   end               


Protecting from bad rules
*************************

Such a versatile system could be open to a lot of ugly bugs, mainly infinite
loops. Thus, try to build your regexps carefully. The embedded anti-loop
subsystem should protect against loglines wrongly generated by alarm plugin.
This system is not perfect so please double-check your regexps.

If you are building a plugin, be sure to prepend your log messages with the
'[uwsgi-alarm' string. These lines will be skipped and directly passed to the
log subsystem. A convenience API function is available: ``uwsgi_log_alarm()``.

How does it work ?
******************

Enabling an alarm automatically puts the uWSGI instance in :term:`log-master
mode`, delegating log writes to the master.  The alarm subsystem is executed by
the master just before passing the log line to the log plugin. Blocking alarm
plugins should run in a thread (like the curl and xmpp one), while the simple
ones (like signal and cmd) may run directly in the master.

Available plugins and their syntax
**********************************

cmd
^^^

Run a shell command, logline is passed to the stdin:

.. parsed-literal::
   cmd:<command>
 

signal
^^^^^^

Raise a [wiki:SignalFramework] uwsgi signal:

.. parsed-literal::
   signal:[signum]

mule
^^^^

Send the logline to a mule waiting for [wiki:Mules messages]

.. parsed-literal::
   mule:[mule_id]

curl
^^^^

Send logline to a curl url. This is not compiled in by default, so if you need to build it just run:

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_curl

.. parsed-literal::
   curl:<url>[;opt1=val1;opt2=val2]


``url`` is a standard curl url, while the options currently exposed are

.. code-block:: c

   "url"
   "mail_to"
   "mail_from"
   "subject"
   "ssl"
   "auth_user"
   "auth_pass"
   "method"
   "timeout"
   "conn_timeout"

So, for sending mail via SMTP AUTH:

.. code-block:: ini

   [uwsgi]
   plugins = alarm_curl
   alarm = test curl:smtp://mail.example.com;mail_to=admin@example.com;mail_from=uwsgi@example.com;auth_user=uwsgi;auth_pass=secret;subject=alarm from uWSGI !!!

Or to POST the logline to an http server protected with basic auth:

.. code-block:: ini

   [uwsgi]
   plugins = alarm_curl
   alarm = test2 curl:http://192.168.173.6:9191/argh;auth_user=topogigio;auth_pass=foobar

xmpp
^^^^

Probably the most funny/interesting one. You need the ``libgloox`` package to build the xmpp alarm plugin (on Debian/Ubuntu, ``apt-get install gloox-dev``).

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_xmpp

.. parsed-literal::
   xmpp:<jid>;<password>;<recipients>

You can set multiple recipients using ',' as delimiter.

.. code-block:: ini

   [uwsgi]
   plugins = alarm_xmpp
   alarm = jabber xmpp:app@example.it;secret1;foo1@foo.it,foo2@foo.it

A funnier thing still about the XMPP plugin is that you will see the Jabber account of your app going down when your app dies...

Some XMPP servers (most notably the OSX server one) requires you to bind to a resource. You can do thus by appending /resource to the JID:

.. code-block:: ini

   [uwsgi]
   plugins = alarm_xmpp
   alarm = jabber xmpp:max@server.local/uWSGI;secret1;foo1@foo.it,foo2@foo.it

speech
^^^^^^

A toy plugin for OSX, used mainly for showing Objective-C integration with
uWSGI.  It simply uses the OSX speech synthesizer to 'announce' the alarm.

.. parsed-literal::
   python uwsgiconfig.py --plugin plugins/alarm_speech

.. code-block:: ini

   [uwsgi]
   plugins = alarm_speech
   http-socket = :8080
   alarm = say speech:
   log-alarm = say .*

Turn on your speakers, run uWSGI and start listening...

airbrake
^^^^^^^^

Starting with 1.9.9 uWSGI includes the ``--alarm-segfault`` option to raise an
alarm when uWSGI segfaults.

The ``airbrake`` plugin can be used to send segfault backtraces to airbrake
compatible servers. Like Airbrake itself and its open source clone errbit
(https://github.com/errbit/errbit), Airbrake support is experimental and it
might not fully work in all cases.

.. code-block:: ini

   plugins = airbrake
   alarm = errbit airbrake:http://errbit.domain.com/notifier_api/v2/notices;apikey=APIKEY;subject=uWSGI segfault
   alarm-segfault = errbit

Note that alarm-segfault does not require airbrake plugin. A backtrace can be sent using any other alarm plugin.
